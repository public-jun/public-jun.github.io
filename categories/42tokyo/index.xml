<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>42Tokyo on Get stronger one day at a time.</title><link>https://public-jun.github.io/categories/42tokyo/</link><description>Recent content in 42Tokyo on Get stronger one day at a time.</description><image><url>https://public-jun.github.io/first-blog-card-fs8.png</url><link>https://public-jun.github.io/first-blog-card-fs8.png</link></image><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Wed, 23 Feb 2022 13:37:59 +0900</lastBuildDate><atom:link href="https://public-jun.github.io/categories/42tokyo/index.xml" rel="self" type="application/rss+xml"/><item><title>c++98 で is_integral 実装</title><link>https://public-jun.github.io/cpp-is-integral/</link><pubDate>Wed, 23 Feb 2022 13:37:59 +0900</pubDate><guid>https://public-jun.github.io/cpp-is-integral/</guid><description>1. はじめに c++98 で STL コンテナを自作するときに is_integral を実装する必要があったので今回はそのまとめです。
2. is_integral とは cppreference.com より //Defined in header &amp;lt;type_traits&amp;gt; namespace std { template &amp;lt;class T&amp;gt; struct is_integral; template &amp;lt;class T&amp;gt; inline constexpr bool is_integral_v = is_integral&amp;lt;T&amp;gt;::value; // C++17 } Checks whether T is an integral type. Provides the member constant value which is equal to true, if T is the type bool, char, char8_t (since C++20), char16_t, char32_t, wchar_t, short, int, long, long long, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants.</description></item><item><title>c++ における typename とは</title><link>https://public-jun.github.io/cpp-typename/</link><pubDate>Sun, 13 Feb 2022 19:19:37 +0900</pubDate><guid>https://public-jun.github.io/cpp-typename/</guid><description>1. はじめに STL コンテナを自作している時、 typename の使い方をしっかり理解していなかったので自分なりにまとめてみました。
2. typename とは cppreference.com typename の説明より
In the template parameter list of a template declaration, typename can be used as an alternative to class to declare type template parameters . Inside a declaration or a definition of a template, typename can be used to declare that a dependent qualified name is a type. c++ のテンプレート宣言時には、型名を明示する際に class の代わりに typename を使用してテンプレートパラメータを宣言することができます。 template&amp;lt;typename T&amp;gt; void f() {} template&amp;lt;class T&amp;gt; void f() {} これはどちらでもコンパイルが通ります。</description></item></channel></rss>