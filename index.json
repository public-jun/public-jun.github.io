[{"content":"1. はじめに  c++98 で STL コンテナを自作するときに is_integral を実装する必要があったので今回はそのまとめです。\n2. is_integral とは   cppreference.com より  //Defined in header \u0026lt;type_traits\u0026gt; namespace std { template \u0026lt;class T\u0026gt; struct is_integral; template \u0026lt;class T\u0026gt; inline constexpr bool is_integral_v = is_integral\u0026lt;T\u0026gt;::value; // C++17 }  Checks whether T is an integral type. Provides the member constant value which is equal to true, if T is the type bool, char, char8_t (since C++20), char16_t, char32_t, wchar_t, short, int, long, long long, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, value is equal to false.\n つまり型Tが整数型かを調べます。 T が整数型かどうかで true_type か false_type になるように integral_constant から継承します。\nis_integral\u0026lt;T\u0026gt;::value で bool値(true もしくは false) を取得することができます。\n 以下のような型が整数型として判定されます。\n bool char char16_t char32_t wchar_t signed char short int int long int long long int unsigned char unsigned short int unsigned int unsigned long int unsigned long long int  enum (列挙型) は c++ では整数型と 判定されません。\n3. 実装  実装のためには以下のクラステンプレートを理解する必要があります。\n integral_constatnt is_integral_helper remove_cv is_integral  integral_constant  template \u0026lt;class _Tp, _Tp __v\u0026gt; struct integral_constant { static const _Tp value = __v; typedef _Tp value_type; typedef integral_constant\u0026lt;_Tp, __v\u0026gt; type; // constexpr operator value_type() const noexcept { return value; } // c++11 なので未実装  const value_type operator()() const { return value; } }; // integral_constantの特殊化 true_type typedef integral_constant\u0026lt;bool, true\u0026gt; true_type; // integral_constantの特殊化 false_type typedef integral_constant\u0026lt;bool, false\u0026gt; false_type; integral_constat は value と value_type の定義を持ち、実体化すると value に bool値が代入されます。\nそれぞれの特殊化は typedef によって true_type もしくは false_type に命名されます。\nis_integral_helper  template \u0026lt;class _Tp\u0026gt; struct is_integral_helper : public false_type {}; // int型でのクラステンプレートの完全特殊化 template \u0026lt;\u0026gt; struct is_integral_helper\u0026lt;int\u0026gt; : public true_type {}; // char型でのクラステンプレートの完全特殊化 template \u0026lt;\u0026gt; struct is_integral_helper\u0026lt;char\u0026gt; : public true_type {}; is_integral_helper はデフォルトでは false_type を継承し、int型やchar型などの整数型の場合は完全特殊化を用いて true_type を継承します。\n同様に他の型での完全特殊化も用意します。ここでは割愛します。\nremove_cv  現時点では int型やchar型は判定できるようになりますが、const int や volatile char などconst修飾子やvolatile修飾子(コンパイルの最適化を抑制する修飾子)がついていても整数型が判定できなければいけません。\n// default template \u0026lt;class _Tp\u0026gt; struct remove_cv { typedef _Tp type; }; // remove const template \u0026lt;class _Tp\u0026gt; struct remove_cv\u0026lt;const _Tp\u0026gt; { typedef _Tp type; }; // remove volatile template \u0026lt;class _Tp\u0026gt; struct remove_cv\u0026lt;volatile _Tp\u0026gt; { typedef _Tp type; }; // remove const volatile template \u0026lt;class _Tp\u0026gt; struct remove_cv\u0026lt;const volatile _Tp\u0026gt; { typedef _Tp type; }; remove_cv は部分特殊化を用いることで const 、 volatile 、 const volatile を取り除いた型を type で取得することができます。\n以上で is_integral を作る材料が揃いました。\nis_integral  template \u0026lt;class _Tp\u0026gt; struct is_integral : is_integral_helper\u0026lt;typename remove_cv\u0026lt;_Tp\u0026gt;::type\u0026gt;::type {}; これが is_integral の定義です。 is_integral\u0026lt;_Tp\u0026gt;::value で bool値を取得できます。\nぱっと見ではわかりづらいかもしれないので、具体例を示します。\n const int の場合   template \u0026lt;class const int\u0026gt; struct is_integral : is_integral_helper\u0026lt;typename remove_cv\u0026lt;const int\u0026gt;::type\u0026gt;::type {}; typename remove_cv\u0026lt;const int\u0026gt;::type に注目して\ntypename remove_cv\u0026lt;const int\u0026gt;::type /* ** const int の const が取り除かれ、 ** typedef int type として命名されるから */ typename int is_integral_helper\u0026lt;typename remove_cv\u0026lt;const int\u0026gt;::type\u0026gt;::type に注目して\n// remove_cv により is_integral_helper\u0026lt;int\u0026gt;::type /* ** template\u0026lt;\u0026gt; ** struct is_integral_helper\u0026lt;int\u0026gt; : public true_type {}; ** より true_type の type メンバが使用できる */ true_type::type /* ** true_type は integral_constant\u0026lt;bool, true\u0026gt; であるから ** 中身は */ struct integral_constant { static const bool value = true; typedef bool value_type; typedef integral_constant\u0026lt;bool, true\u0026gt; type; const value_type operator()() const { return value; } }; /* ** typedef integral_constant\u0026lt;bool, type\u0026gt; type; より */ struct is_integral : integral_constant\u0026lt;bool, true\u0026gt; {}; /* ** is_integral は integral_constant\u0026lt;bool, true\u0026gt; のメンバを利用できるから */ is_integral::value // true 流れとしては以上です。\n最後に  enable_if で今回の is_integral は用いるのですが、enable_if の実装自体はそんなに難しそうじゃなかったので、この記事に追記してもいいかもしれません。 完全特殊化、部分特殊化の理解が深まってよかったです。\n次は enable_if のこと書きます。\n. 参考URL  cppreference.com cplusplus cpprefjp gcc のソースコード is_integral 該当ファイル llvm のソースコード is_integral 該当ファイル  ","permalink":"https://public-jun.github.io/cpp-is-integral/","summary":"1. はじめに  c++98 で STL コンテナを自作するときに is_integral を実装する必要があったので今回はそのまとめです。\n2. is_integral とは   cppreference.com より  //Defined in header \u0026lt;type_traits\u0026gt; namespace std { template \u0026lt;class T\u0026gt; struct is_integral; template \u0026lt;class T\u0026gt; inline constexpr bool is_integral_v = is_integral\u0026lt;T\u0026gt;::value; // C++17 }  Checks whether T is an integral type. Provides the member constant value which is equal to true, if T is the type bool, char, char8_t (since C++20), char16_t, char32_t, wchar_t, short, int, long, long long, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants.","title":"c++98 で is_integral 実装"},{"content":"1. はじめに  STL コンテナを自作している時、 typename の使い方をしっかり理解していなかったので自分なりにまとめてみました。\n2. typename とは  cppreference.com typename の説明より\n  In the template parameter list of a template declaration, typename can be used as an alternative to class to declare type template parameters . Inside a declaration or a definition of a template, typename can be used to declare that a dependent qualified name is a type.    c++ のテンプレート宣言時には、型名を明示する際に class の代わりに typename を使用してテンプレートパラメータを宣言することができます。  template\u0026lt;typename T\u0026gt; void f() {} template\u0026lt;class T\u0026gt; void f() {} これはどちらでもコンパイルが通ります。\n テンプレートの宣言や定義の中で， typename はテンプレートパレメータ内部にネストされた依存型名が明示的に型である宣言をするために使うことができます．  例えば、以下の例を考えてみます。\n#include \u0026lt;iostream\u0026gt; class my_class { public: enum type_ { val1 = 100 }; }; template\u0026lt;typename T\u0026gt; class test_my_class { public: void print() { // T::type_ val1 = T::type_::val1;  typename T::type_ val1 = T::type_::val1; std::cout \u0026lt;\u0026lt; val1 \u0026lt;\u0026lt; std::endl; } }; int main(int, char**) { test_my_class\u0026lt;my_class\u0026gt; tc; tc.print(); return 0; } test_my_class のクラステンプレートのテンプレート引数として my_class が与えられた状況です。\n// T::type_ val1 = T::type_::val1; typename T::type_ val1 = T::type_::val1; 上記 2 行の違いは typename がついているかどうかです。 1行目をコメントアウトしなければ、コンパイルが成功しません。 これはコンパイル時には T::type_ が クラス名::型 なのか クラス名::定数 なのか判断できないからです。\nこの問題を解決するために、ネストされた依存名(T) の 型(type_) を使う場合、明示的に typename を書きます。\ntypename Foo\u0026lt;T\u0026gt;::xxx //xxxは型名 最後に  今回は typename についてまとめてみました。 これで少し STL コンテナのコードを読めそうです。\n参考URL  https://en.cppreference.com/w/cpp/keyword/typename https://marycore.jp/prog/cpp/template-class-typename/ https://daily-tech.hatenablog.com/entry/2018/12/01/103658  ","permalink":"https://public-jun.github.io/cpp-typename/","summary":"1. はじめに  STL コンテナを自作している時、 typename の使い方をしっかり理解していなかったので自分なりにまとめてみました。\n2. typename とは  cppreference.com typename の説明より\n  In the template parameter list of a template declaration, typename can be used as an alternative to class to declare type template parameters . Inside a declaration or a definition of a template, typename can be used to declare that a dependent qualified name is a type.    c++ のテンプレート宣言時には、型名を明示する際に class の代わりに typename を使用してテンプレートパラメータを宣言することができます。  template\u0026lt;typename T\u0026gt; void f() {} template\u0026lt;class T\u0026gt; void f() {} これはどちらでもコンパイルが通ります。","title":"c++ における typename とは"},{"content":"1. はじめに Hugoで作ったサイトは共有された時、ブログカードはデフォルトでは作成されません。 ブログカードは下記の画像です。 タイトル、説明、画像といったものがのっています。 これらの情報を提供しているのが Open Graph Protocol(OGP) です。\n今回はブログカードの画像を用意して、Hugo の config ファイルに OGP の設定を記述しブログカードを作成します。\n2. Open Graph Protocol(OGP)、OGP 画像って何？？  公式より\n The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.\n OGP を用いると任意の Web ページをリッチなソーシャルグラフのオブジェクトにすることができます。\n要するに、ページのブログカードに必要な情報を取ってきてブログカードを作る仕組みの一つです。\nHTML の head 領域に任意のデータを記述できる meta 要素を追加し、ページ情報を記載することができます。OGP のデータであることを示すために、property 属性に og: から始まる値を記述します。\n基本的に必要なのは以下の 4 つです。\n og:title \u0026hellip; ページのタイトル og:type\u0026hellip; ページのオブジェクトタイプを表す、トップページは *website\u0026quot; 、それ以外は \u0026ldquo;article\u0026rdquo; og:image\u0026hellip; ページの画像 og:url\u0026hellip; ページのURL  この他にも og:site_name や og:description もよく利用されます。\nこのブログのトップページのOGP設定は以下\n\u0026lt;head\u0026gt; . . \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;Get stronger one day at a time.\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;1日ひとつ強くなる42Tokyo生の個人ブログです。\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;website\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://public-jun.github.io/\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;https://public-jun.github.io/first-blog-card-fs8.png\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:site_name\u0026#34; content=\u0026#34;jnakahod\u0026#39;s blog\u0026#34;\u0026gt; . \u0026lt;/head\u0026gt; 3. GIMPを使って画像作成  ドット絵の作成にはミニドット絵メーカー3、それを加工し編集するのに画像編集ソフトGIMP を利用しました。\nどちらも無料で使えます。 GIMP は OSS プロジェクトで有料サービスに劣らないくらい機能が盛り盛りだったのでびっくりしました。\n4. configファイル設定  Hugo には予め OGP 情報を head 内に埋め込む機能がついているので、config ファイルを設定し有効にしていきます。\n以下公式サイトの設定\nconfig.yml\nparams: description: Text about my cool site images: - site-feature-image.jpg title: My cool site taxonomies: series: series 記事それぞれに情報を付与することも可能です。\ncontent/blog/my-post.yaml もしくは front matter 内に記述\naudio: [] date: \u0026#34;2006-01-02\u0026#34; description: Text about this post images: - post-cover.png series: [] tags: [] title: Post title videos: [] 私の config.yaml の場合は以下の設定です。\nparams: . . description: 1日ひとつ強くなる42Tokyo生の個人ブログです。 images: - first-blog-card-fs8.png title: jnakahod\u0026#39;s blog Twitter カードもこれで設定できたことになります。\nlayout/partials/head.html もしくは thema/テーマ名/layout/partials/head.html の中の\n{{- template \u0026#34;partials/templates/opengraph.html\u0026#34; . }} {{- template \u0026#34;partials/templates/twitter_cards.html\u0026#34; . }} が有効になります。\nファイルの構成はテーマに依存するので、使用しているものに合わせて利用してください。ない場合は、追記してください。\n5. ブログカード完成 これでデプロイすると冒頭のようなブログカードの完成です。\n OGP確認  これを使うと各SNSにどのように共有されるのか確認できます。\n最後に  これでとりあえず欲しい機能は揃ってきたので、あとは淡々とアウトプットを増やしてきます。 また Hugo で気になる機能があったら積極的に触ってみようと思います。\nではまた👋\n","permalink":"https://public-jun.github.io/make-blog-card/","summary":"1. はじめに Hugoで作ったサイトは共有された時、ブログカードはデフォルトでは作成されません。 ブログカードは下記の画像です。 タイトル、説明、画像といったものがのっています。 これらの情報を提供しているのが Open Graph Protocol(OGP) です。\n今回はブログカードの画像を用意して、Hugo の config ファイルに OGP の設定を記述しブログカードを作成します。\n2. Open Graph Protocol(OGP)、OGP 画像って何？？  公式より\n The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.\n OGP を用いると任意の Web ページをリッチなソーシャルグラフのオブジェクトにすることができます。\n要するに、ページのブログカードに必要な情報を取ってきてブログカードを作る仕組みの一つです。","title":"Hugo で作ったサイトにブログカード(OGP)を設定"},{"content":"1. はじめに Hugo でブログを作ってみたものの、デフォルトではコメント機能はついていません。\n今回はUtterancesを使ってみたいと思います。\n2. Hugoのコメント機能  Hugo にコメント機能をつける場合、いくつか選択肢があります。\n鉄板は Disqus でしょうか。これは公式が Hugo をサポートしています。\nDocs にも唯一設定手順が書いてあります。\n以下、ドキュメントに紹介されているもの\n Cactus Comments Commento Graph Comment Hyvor Talk IntenseDebate Isso Muut Remark42 Staticman Talkyard Utterances  Disqus を使わない理由は無料プランだと広告がつくみたいです。あと登録するのも少し面倒に感じました。\nでも今回使う Utterances は GitHub のアカウントだけなので、(一応想定読者はテックの人なので) GitHub の認証のみならコメントのハードルも低いかなと思いこれに決めました。\nあと見た目がいい😊\nUtterancesとは？？  A lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more!\n Utterances は軽量なコンポーネントと GitHub issues にコメントを書きこむ bot を提供しています。 これを使うと GitHub の issue と記事やページを紐付け、ページに issue を表示することができます。\nOSS プロジェクトでスター6kついており、かなりの人が使っています。\nテーマもいくつか用意されていて良きです。\nトラックなし、広告なし、その上機能は全て無料です。\n3. Utterancesの導入  今回は Utterances に絞って説明していきます。 前提として Hugo のサイトを GitHub の public なリポジトリで管理しているとします。 また使用テーマは PaperMod です。\n基本的には公式サイトを見ながら設定していけば ok です。\n  リポジトリに utterances app をインストール\n  フォームにリポジトリの所有者とリポジトリ名を入力 私の場合は public-jun/public-jun.github.io です。\n  記事と GitHub の issue を紐付ける。今回は pathname で設定します。   GitHub の issue でのラベルを決める。これは任意のラベルで大丈夫です。今回はコメントと分かるように Comment とします。\n  テーマを決める。お好きなテーマを選んでください。\n  ここまですると一番したに設定用のスクリプトが表示されます。\nこれを layout/partials/comments.html 新たに作成し貼り付けます。\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;owner/repo\u0026#34; issue-term=\u0026#34;pathname\u0026#34; label=\u0026#34;Comment\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; confing.yml\nparams: comments: true これを追記することでthemes/PaperMod/layouts/_default/single.html の\n{{- if (.Param \u0026#34;comments\u0026#34;) }} {{- partial \u0026#34;comments.html\u0026#34; . }} {{- end }} が有効となりコメントが表示されます。\n4. コメントする  実際にコメントしてみるとこんな感じ 5. 最後に これでいい感じにコメント機能が追加できたと思います。 もし読んでくださった方がいたら、コメントくれると嬉しいです😄\nダークモードとライトモードでテーマが切り替えられるようにしたいです。 明日はそろそろ取り組んでいる課題の記事にしていきたい。\n参考URL  https://utteranc.es/ https://miyauchi.dev/ja/posts/comment-system/ https://mscipio.github.io/post/utterances-comment-engine/  ","permalink":"https://public-jun.github.io/Hugo-utterances/","summary":"1. はじめに Hugo でブログを作ってみたものの、デフォルトではコメント機能はついていません。\n今回はUtterancesを使ってみたいと思います。\n2. Hugoのコメント機能  Hugo にコメント機能をつける場合、いくつか選択肢があります。\n鉄板は Disqus でしょうか。これは公式が Hugo をサポートしています。\nDocs にも唯一設定手順が書いてあります。\n以下、ドキュメントに紹介されているもの\n Cactus Comments Commento Graph Comment Hyvor Talk IntenseDebate Isso Muut Remark42 Staticman Talkyard Utterances  Disqus を使わない理由は無料プランだと広告がつくみたいです。あと登録するのも少し面倒に感じました。\nでも今回使う Utterances は GitHub のアカウントだけなので、(一応想定読者はテックの人なので) GitHub の認証のみならコメントのハードルも低いかなと思いこれに決めました。\nあと見た目がいい😊\nUtterancesとは？？  A lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more!\n Utterances は軽量なコンポーネントと GitHub issues にコメントを書きこむ bot を提供しています。 これを使うと GitHub の issue と記事やページを紐付け、ページに issue を表示することができます。","title":"HugoのサイトにUtterancesを使ってコメント機能をつける"},{"content":"1. はじめに Hugoで作った静的サイトはそのままの設定ではGoogle検索にはかからないので、いくつか設定をしないといけません。\nGoogle検索で表示されるまで   Google Analyticsに登録 Google Search Consoleに登録  今回は Google Analytics 登録編です。\n2. やってみる 測定を開始をクリック\n任意のアカウント名にして次へ\n プロパティ(サイトやアプリの名前) タイムゾーン 通貨 を入力して次へ  上から順に記入していけば大丈夫です。\nプラットフォームはwebを選択\nwebサイト のURLを入力します。このサイトではhttps:///public-jun.github.ioのようになります。 ストリーム名はwebサイトのタイトルを入力すれば大丈夫です。\nストリームを作成すると測定IDが生成されます。\nHugoの設定  Hugoの場合、google analytics設定用のテンプレートが用意されているのでconfigファイルに追記します。\nconfig.yml:(Google Analytics v4 (gtag.js))の場合、測定IDがGからはじまる\ngoogleAnalytics: G-MEASUREMENT_ID config.yml:Google Analytics v3 (analytics.js)の場合、測定IDがUAからはじまる\ngoogleAnalytics: UA-PROPERTY_ID 現在はgtagsで設定しておけば良いと思います。\nこれでHugo側の設定は完了です。 アップロードして確認してみましょう。\nGoogle Analyticsのレポート -\u0026gt; リアルタイム を確認してみて、自分がアクセスしたときにユーザー数が0以外であれば成功です😄\n最後に 次回はGoogle Search Consoleの設定をしてみたいと思いますがどうやら登録に時間がかかる場合もあるらしく、まだできていません。 登録出来次第まとめたいと思います。\n","permalink":"https://public-jun.github.io/Hugo-google-analytics/","summary":"1. はじめに Hugoで作った静的サイトはそのままの設定ではGoogle検索にはかからないので、いくつか設定をしないといけません。\nGoogle検索で表示されるまで   Google Analyticsに登録 Google Search Consoleに登録  今回は Google Analytics 登録編です。\n2. やってみる 測定を開始をクリック\n任意のアカウント名にして次へ\n プロパティ(サイトやアプリの名前) タイムゾーン 通貨 を入力して次へ  上から順に記入していけば大丈夫です。\nプラットフォームはwebを選択\nwebサイト のURLを入力します。このサイトではhttps:///public-jun.github.ioのようになります。 ストリーム名はwebサイトのタイトルを入力すれば大丈夫です。\nストリームを作成すると測定IDが生成されます。\nHugoの設定  Hugoの場合、google analytics設定用のテンプレートが用意されているのでconfigファイルに追記します。\nconfig.yml:(Google Analytics v4 (gtag.js))の場合、測定IDがGからはじまる\ngoogleAnalytics: G-MEASUREMENT_ID config.yml:Google Analytics v3 (analytics.js)の場合、測定IDがUAからはじまる\ngoogleAnalytics: UA-PROPERTY_ID 現在はgtagsで設定しておけば良いと思います。\nこれでHugo側の設定は完了です。 アップロードして確認してみましょう。\nGoogle Analyticsのレポート -\u0026gt; リアルタイム を確認してみて、自分がアクセスしたときにユーザー数が0以外であれば成功です😄\n最後に 次回はGoogle Search Consoleの設定をしてみたいと思いますがどうやら登録に時間がかかる場合もあるらしく、まだできていません。 登録出来次第まとめたいと思います。","title":"HugoでGoogle Analyticsを使う"},{"content":"きっかけ ブログにタグ機能が欲しかったから。\nTaxonomyって何？？  Hugo includes support for user-defined groupings of content called taxonomies. Taxonomies are classifications of logical relationships between content.\n タグやカテゴリなどのユーザーが定義した分類のことをタクソノミーという。\n  タクソノミー(Taxonomy)\nコンテンツをグルーピングするための分類法\n  ターム(Term)\n実際の具体的なタグやカテゴリの値\n  Taxonomyを使う  Hugoはデフォルトでタグとカテゴリをサポートしている。\nconfingの設定 config.yml\ntaxonomies: category: categories tag: tags https://[サイトURL]/tags/\nhttps://[サイトURL]/categories/\n上記のURLにアクセスするとタグ一覧、カテゴリ一覧ページへアクセスできる。\nちなみにこのサイトでは\n  https://public-jun.github.io/tags/\n  https://public-jun.github.io/categories/\n  となる。\n記事の Front matter内でタグ、カテゴリ追加 contents/posts/../記事.md\n--- title: \u0026#34;HugoのサイトにTag機能を追加\u0026#34; date: 2022-02-04T15:39:20+09:00 draft: false tags: [42Tokyo, blog, Hugo, TIL] //追加 categories: [Tech] //追加 . . --- これで「42Tokyo」、「blog」、「Hugo」、「TIL」タグが追加され、\n記事自身は「Tech」というカテゴリに分類された。\n画面上部にMenu表示(Papermod)  PaperModテーマはホームページ右上にMenu(ページへのショートカット)を作成することができる。\nconfig.yml\nmenu: main: - identifier: tags name: Tags url: /tags/ weight: 1 - identifier: categories name: Categories url: /categories/ weight: 2 このように設定すると画面右上にTagsとcategoriesへのMenuを表示することができる。\n終わり  次はコメント機能の追加やgoogle analyticsの導入にチャレンジしよかな。\n42Tokyoの課題も学んだことアウトプットしていきます🙌\n参考URL   HUGO document\n  https://hugo-de-blog.com/hugo-taxonomy/\n  https://maku77.github.io/hugo/taxonomy/basic.html\n  ","permalink":"https://public-jun.github.io/custom-taxonomies/","summary":"きっかけ ブログにタグ機能が欲しかったから。\nTaxonomyって何？？  Hugo includes support for user-defined groupings of content called taxonomies. Taxonomies are classifications of logical relationships between content.\n タグやカテゴリなどのユーザーが定義した分類のことをタクソノミーという。\n  タクソノミー(Taxonomy)\nコンテンツをグルーピングするための分類法\n  ターム(Term)\n実際の具体的なタグやカテゴリの値\n  Taxonomyを使う  Hugoはデフォルトでタグとカテゴリをサポートしている。\nconfingの設定 config.yml\ntaxonomies: category: categories tag: tags https://[サイトURL]/tags/\nhttps://[サイトURL]/categories/\n上記のURLにアクセスするとタグ一覧、カテゴリ一覧ページへアクセスできる。\nちなみにこのサイトでは\n  https://public-jun.github.io/tags/\n  https://public-jun.github.io/categories/\n  となる。\n記事の Front matter内でタグ、カテゴリ追加 contents/posts/../記事.md\n--- title: \u0026#34;HugoのサイトにTag機能を追加\u0026#34; date: 2022-02-04T15:39:20+09:00 draft: false tags: [42Tokyo, blog, Hugo, TIL] //追加 categories: [Tech] //追加 .","title":"HugoのサイトにTag機能を追加"},{"content":"こんにちは、jnakahodです\n日々学んだことを気軽にアウトプットしようと思いブログを作りました。 他のブログサービスを使うより気軽になんでも書けるので個人ブログにしました。\nできるだけ毎日、その日学んだこと投稿するのが目標です。\nちゃんとした記事ははてブとかに投稿しようかな。。\n","permalink":"https://public-jun.github.io/posts/my-first-posts/","summary":"こんにちは、jnakahodです\n日々学んだことを気軽にアウトプットしようと思いブログを作りました。 他のブログサービスを使うより気軽になんでも書けるので個人ブログにしました。\nできるだけ毎日、その日学んだこと投稿するのが目標です。\nちゃんとした記事ははてブとかに投稿しようかな。。","title":"Hello World!!"}]