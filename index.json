[{"content":"1. はじめに  前回の基礎知識編の続き、実装編です。 この記事では、vectorのイテレータを作ります。\n2. 概要を掴む  実装のイメージをつけるために、江添亮のC++入門のstd::arrayから vectorの実装 : メモリー確保までを写経しました。\nこの資料ではイテレータをポインタのエイリアスで実装しています。\nllvm や gcc はイテレータを用意しているので、最終的にはポインタで操作しているところをイテレータに置き換えていきます。\n3. イテレータ実装 自作 vector は ftという名前空間に作ります。\niterator_traits  iterator_traits.hpp\n#ifndef ITERATOR_TRAITS_HPP #define ITERATOR_TRAITS_HPP  #include \u0026lt;cstddef\u0026gt; // ptrdiff_t#include \u0026lt;iterator\u0026gt; namespace ft {  /// primary iterator_traits template \u0026lt;class Iterator\u0026gt; struct iterator_traits {  typedef typename Iterator::difference_type difference_type;  typedef typename Iterator::value_type value_type;  typedef typename Iterator::pointer pointer;  typedef typename Iterator::reference reference;  typedef typename Iterator::iterator_category iterator_category; };  /// Partial specialization for pointer types template \u0026lt;class T\u0026gt; struct iterator_traits\u0026lt;T*\u0026gt; {  typedef ptrdiff_t difference_type;  typedef T value_type;  typedef T* pointer;  typedef T\u0026amp; reference;  typedef std::random_access_iterator_tag iterator_category; };  /// Partial specialization for const pointer types. template \u0026lt;class T\u0026gt; struct iterator_traits\u0026lt;const T*\u0026gt; {  typedef ptrdiff_t difference_type;  typedef T value_type;  typedef const T* pointer;  typedef const T\u0026amp; reference;  typedef std::random_access_iterator_tag iterator_category; }; } // namespace ft  #endif iterator_traits は、イテレータに関する型情報を取得するためのクラスです。 部分特殊化により、ポインタにも対応しています。イテレータは少なくともこれらが定義されなけらばいけません。\niterator_traits が保持する情報は以下です。\n   型 説明     difference_type イテレータの差を示す符号付き整数型   value_type イテレータが示す値型   pointer ポインタ型   reference イテレータが示す参照型   iterator_category イテレータの分類をを表す型    wrap_iter (vector のイテレータ) wrap_iter.hpp\n#ifndef WRAP_ITER_HPP #define WRAP_ITER_HPP  #include \u0026lt;iterator_traits.hpp\u0026gt; namespace ft { template \u0026lt;class Iter\u0026gt; class wrap_iter { protected:  Iter current_;  typedef iterator_traits\u0026lt;Iter\u0026gt; traits_type;  public:  typedef Iter iterator_type;  typedef typename traits_type::value_type value_type;  typedef typename traits_type::difference_type difference_type;  typedef typename traits_type::pointer pointer;  typedef typename traits_type::reference reference;  typedef typename traits_type::iterator_category iterator_category;   // Member functions  //// constructor  wrap_iter() : current_(NULL) {}  explicit wrap_iter(iterator_type x) : current_(x) {}  //// copy constructor  template \u0026lt;class U\u0026gt;  wrap_iter(const wrap_iter\u0026lt;U\u0026gt;\u0026amp; other) : current_(other.base())  {}   //// assignment operator  template \u0026lt;class U\u0026gt;  wrap_iter\u0026amp; operator=(const wrap_iter\u0026lt;U\u0026gt;\u0026amp; other)  {  // std::cout \u0026lt;\u0026lt; \u0026#34;assignment called\u0026#34; \u0026lt;\u0026lt; std::endl;  if (current_ != other.base())  current_ = other.base();  return *this;  }  //// destructor  ~wrap_iter() {}   iterator_type base() const { return current_; }  reference operator*() const { return *current_; }  pointer operator-\u0026gt;() const { return current_; }  reference operator[](difference_type n) const { return *(*this + n); }  wrap_iter\u0026amp; operator++()  {  ++current_;  return *this;  }  wrap_iter\u0026amp; operator--()  {  --current_;  return *this;  }  wrap_iter operator++(int)  {  wrap_iter tmp = *this;  ++current_;  return tmp;  }  wrap_iter operator--(int)  {  wrap_iter tmp = *this;  --current_;  return tmp;  }  wrap_iter operator+(difference_type n) const  {  return wrap_iter(current_ + n);  }  wrap_iter operator-(difference_type n) const  {  return wrap_iter(current_ - n);  }  wrap_iter\u0026amp; operator+=(difference_type n)  {  current_ += n;  return *this;  }  wrap_iter\u0026amp; operator-=(difference_type n)  {  current_ -= n;  return *this;  } }; // // Non member-functions... // } // namespace ft  #endif 今回 vector のイテレータは wrap_iterとします。命名は llvm の実装から取ってきました。イテレータの種類は ランダムアクセスイテレータ なのでその要件を満たす必要があります。\nvector のイテレータが保持するメンバ変数は上記の iterator_traits の型情報と、現在のポインタを表す current_ です。vector は各要素が連続して配置しているので、ポインタを操作し要素にアクセスすることができます。\n非メンバ関数はこの記事には書いてません。別途リポジトリを参照してください。\nこれで vector のイテレータは実装完了です。\n最後に 次回は、vectorの実装に入っていきます。\n参考URL  https://cpprefjp.github.io/reference/iterator/iterator_traits.html https://marycore.jp/prog/cpp/implement-iterator-traits/  ","permalink":"https://public-jun.github.io/cpp-my-vector2/","summary":"1. はじめに  前回の基礎知識編の続き、実装編です。 この記事では、vectorのイテレータを作ります。\n2. 概要を掴む  実装のイメージをつけるために、江添亮のC++入門のstd::arrayから vectorの実装 : メモリー確保までを写経しました。\nこの資料ではイテレータをポインタのエイリアスで実装しています。\nllvm や gcc はイテレータを用意しているので、最終的にはポインタで操作しているところをイテレータに置き換えていきます。\n3. イテレータ実装 自作 vector は ftという名前空間に作ります。\niterator_traits  iterator_traits.hpp\n#ifndef ITERATOR_TRAITS_HPP #define ITERATOR_TRAITS_HPP  #include \u0026lt;cstddef\u0026gt; // ptrdiff_t#include \u0026lt;iterator\u0026gt; namespace ft {  /// primary iterator_traits template \u0026lt;class Iterator\u0026gt; struct iterator_traits {  typedef typename Iterator::difference_type difference_type;  typedef typename Iterator::value_type value_type;  typedef typename Iterator::pointer pointer;  typedef typename Iterator::reference reference;  typedef typename Iterator::iterator_category iterator_category; };  /// Partial specialization for pointer types template \u0026lt;class T\u0026gt; struct iterator_traits\u0026lt;T*\u0026gt; {  typedef ptrdiff_t difference_type;  typedef T value_type;  typedef T* pointer;  typedef T\u0026amp; reference;  typedef std::random_access_iterator_tag iterator_category; };  /// Partial specialization for const pointer types.","title":"c++98で自作 vector (2)"},{"content":"1. はじめに  c++98 で STL コンテナの vector(c++98 ver) を自作していきます。\n完成形は cppreferece 、 C++ Reference の vector を目指します。\n2. 基礎知識編 コンテナ  クラスや構造体、基本型(int, charなど)を保持するデータ構造(入れ物)。\nvector や map 、stack 、set などデータ保持の方法は、用途に合わせて様々なものが提供されています。\nイテレータ  コンテナの個々の要素を参照するためのクラスです。\nこの特徴から、イテレータは ポインタを抽象化したクラス と捉えることもできます。しかし、全てのイテレータがポインタの全機能を備えているわけではありません。\n後述するアルゴリズムはコンテナのイテレータを用いて、コンテナを操作することができます。 イテレータがコンテナとアルゴリズムを媒介するインターフェースになることで、異なるデータ構造にも関わらす、コンテナを操作することができます。\nイテレータを用いて要素の移動、参照、変更が行えます。\n ポインタのように *iterator と * をつけることで、要素への参照が可能です。 ++iterator とすると、次の要素を指します。  これらの操作はイテレータの種類によっても異なります。(wikiより)\n InputIterator(入力イテレータ)  要素への 読み取り専用 アクセスを提供するイテレータ。 要素への読み取りが可能であれば、InputIterator とみなせます。(istream_iteratorなど)   OutputIterator(出力イテレータ)  要素への 書き込み専用 アクセスを提供するイテレータ。 要素への書き込みが可能であれば、OutputIterator とみなせます。(ostream_iteratorなど)   ForwardIterator(前方向イテレータ)  一旦前に進めると、逆方向には戻れない イテレータ。 要素への読み取り、書き込みが可能であれば、ForwardIterator とみなせます。(単方向リストのコンテナのイテレータなど)   BidirectionalIterator(双方向イテレータ)  前方、後方どちらにも進める 機能を持つイテレータ。 前方向イテレータの要件に加えて、デクリメント(- -)が可能であれば、 BidrectionalIterator とみなせます。(list、set、multiset、map、multimapのコンテナのイテレータなど)   RandomAccessIterator(ランダムアクセスイテレータ)  ポインタのように ランダムにアクセスが行える イテレータ。 BidirectionalIterator の要件に加え、算術演算(+, -, +=, -=)が可能であれば RandomAccessIterator とみなせます。(vector、array、dequeのイテレータなど)    全てのイテレータはインクリメント(++)、等号比較(it1 != it2)、デリファレンス(*it)可能でなければならない。\nまた、入力イテレータ、前方向イテレータ、双方向イテレータ、ランダムアクセスイテレータは順に 継承関係 になっています。例えば、前方向イテレータは入力イテレータとみなすことができます。\nアルゴリズム  コンテナのイテレータを引数として受け取り、コンテナの要素に対して操作を行う関数群です。 イテレータの範囲内から任意の値を検索する std::find() や イテレータの範囲を別のイテレータにコピーする std::copy() など様々なものがあります。\n3. vector とは？？  std::vector は c++ で標準で使用することができる 動的配列(可変長配列) クラスです。\n通常の配列はサイズを予め指定する必要があり、実行時に動的にサイズを変更することができません。\n一方、動的配列はサイズを 自由に増減 することができます。 保持する要素数に合わせて、サイズを変更できるのでメモリ領域を無駄に確保せずに済みます。\n通常の配列と同じように各要素は連続して配置しているので、イテレータだけでなく、[]演算子で添字でアクセスすることが可能です。\n vector のデータ構造は図のようになっており、実際の要素数(size)は last - first となり、要素をいれることができる領域(capacity) capacity - first になります。\nメモリ領域の再確保は全ての要素が新しいメモリ領域にコピーされるため時間がかかります。vector は余分にメモリを確保することで、要素を追加する度にメモリを再確保する必要がなくなります。\n要素数がcapacityを超える場合は、メモリ領域の再確保が行われます。\n最後に これらの特徴を押さえて次回は vector のイテレータ実装編です。\n参考URL  https://nafuka.hatenablog.com/entry/2021/11/15/184200 https://note.com/syamashi/n/n55ee0dad207d http://vivi.dyndns.org/tech/cpp/vector.html https://ja.wikipedia.org/wiki/Standard_Template_Library  ","permalink":"https://public-jun.github.io/cpp-my-vector1/","summary":"1. はじめに  c++98 で STL コンテナの vector(c++98 ver) を自作していきます。\n完成形は cppreferece 、 C++ Reference の vector を目指します。\n2. 基礎知識編 コンテナ  クラスや構造体、基本型(int, charなど)を保持するデータ構造(入れ物)。\nvector や map 、stack 、set などデータ保持の方法は、用途に合わせて様々なものが提供されています。\nイテレータ  コンテナの個々の要素を参照するためのクラスです。\nこの特徴から、イテレータは ポインタを抽象化したクラス と捉えることもできます。しかし、全てのイテレータがポインタの全機能を備えているわけではありません。\n後述するアルゴリズムはコンテナのイテレータを用いて、コンテナを操作することができます。 イテレータがコンテナとアルゴリズムを媒介するインターフェースになることで、異なるデータ構造にも関わらす、コンテナを操作することができます。\nイテレータを用いて要素の移動、参照、変更が行えます。\n ポインタのように *iterator と * をつけることで、要素への参照が可能です。 ++iterator とすると、次の要素を指します。  これらの操作はイテレータの種類によっても異なります。(wikiより)\n InputIterator(入力イテレータ)  要素への 読み取り専用 アクセスを提供するイテレータ。 要素への読み取りが可能であれば、InputIterator とみなせます。(istream_iteratorなど)   OutputIterator(出力イテレータ)  要素への 書き込み専用 アクセスを提供するイテレータ。 要素への書き込みが可能であれば、OutputIterator とみなせます。(ostream_iteratorなど)   ForwardIterator(前方向イテレータ)  一旦前に進めると、逆方向には戻れない イテレータ。 要素への読み取り、書き込みが可能であれば、ForwardIterator とみなせます。(単方向リストのコンテナのイテレータなど)   BidirectionalIterator(双方向イテレータ)  前方、後方どちらにも進める 機能を持つイテレータ。 前方向イテレータの要件に加えて、デクリメント(- -)が可能であれば、 BidrectionalIterator とみなせます。(list、set、multiset、map、multimapのコンテナのイテレータなど)   RandomAccessIterator(ランダムアクセスイテレータ)  ポインタのように ランダムにアクセスが行える イテレータ。 BidirectionalIterator の要件に加え、算術演算(+, -, +=, -=)が可能であれば RandomAccessIterator とみなせます。(vector、array、dequeのイテレータなど)    全てのイテレータはインクリメント(++)、等号比較(it1 !","title":"c++98で自作 vector (1)"},{"content":"1. はじめに  c++98 で STL コンテナを自作するときに enable_if を実装する必要があったので今回はそのまとめです。あくまで、c++98 ベースで作っていきます。\n前回の is_integral を使うので、場合によっては参照してください。\n2. SFINAE とは  cpprefjp より引用\n 「SFINAE (Substitution Failure Is Not An Errorの略称、スフィネェと読む)」は、テンプレートの置き換えに失敗した際に、即時にコンパイルエラーとはせず、置き換えに失敗した関数をオーバーロード解決の候補から除外するという言語機能である。\n テンプレート引数の展開に不正があっても、エラーにはならず候補から外され、コンパイルは続行される。\n残った候補の中から置き換えに成功したものを実行する。\nstruct Test {  typedef void type; };  template \u0026lt;typename T\u0026gt; void f(typename T::type) {} // 定義#1  template \u0026lt;typename T\u0026gt; void f(T) {} // 定義#2  int main() {  f\u0026lt;Test\u0026gt;(10); // 定義#1 の呼び出し  f\u0026lt;int\u0026gt;(10); // 定義#2 の呼び出し }  f\u0026lt;Test\u0026gt;(10) について、Test::type が存在するので 定義1 が実体化する。 f\u0026lt;int\u0026gt;(10) について、int型は int::type が存在しないので 定義1 が候補から除外され、 定義2 が実体化される。  このようにテンプレート実引数の型を調べて、実体化するテンプレート定義を決定することができる特徴がある。\nenable_if  定義\n// プライマリー (primary template) template\u0026lt;bool, class _Tp = void\u0026gt; struct enable_if {};  // 部分特殊化 (Partial specialization for true) template \u0026lt;class _Tp\u0026gt; struct enable_if \u0026lt;true, _Tp\u0026gt; {  typedef _Tp type; }; プライマリーの最後のテンプレート仮引数に class _Tp = void を用意し、呼び出し時に enable_if\u0026lt;bool値, 型\u0026gt; で使用することができます。\n_Tp は void型が指定されており省略可能なので、実際には enable_if\u0026lt;bool値\u0026gt;::type で使用することが多いです。\n整数型かどうか  整数型かどうか判定するis_integral は is_integral\u0026lt;T\u0026gt;::value で bool値を取り出すことができました。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;type_traits\u0026gt; template \u0026lt;class T\u0026gt; void f(T, typename std::enable_if\u0026lt;std::is_integral\u0026lt;T\u0026gt;::value\u0026gt;::type* = NULL) {  cout \u0026lt;\u0026lt; \u0026#34;Tは整数型\u0026#34; \u0026lt;\u0026lt; endl; }  template \u0026lt;class T\u0026gt; void f(T, typename std::enable_if\u0026lt;!std::is_integral\u0026lt;T\u0026gt;::value\u0026gt;::type* = NULL) {  cout \u0026lt;\u0026lt; \u0026#34;Tは整数型以外\u0026#34; \u0026lt;\u0026lt; endl; }  int main() {  f(3); // Tは整数型  f(\u0026#34;hello\u0026#34;); // Tは整数型以外 } このように enable_if と組み合わせて書くことができます。\nenable_if\u0026lt;true\u0026gt; のときは type が定義されているので enable_if\u0026lt;true\u0026gt;::type を取得できますが、false のときは定義されていないので取得できません。\n最後に  今日は enable_if についてまとめてみました。SFINAE を通して改めてメタプログラミング難しいなと思いました。もう少しcppになれないといけないです。\n参考URL  cpprefjp wiki Theoride Technology 部分的特殊化で良く使う部品とSFINAEの利用方法 Theoride Technology 部分的特殊化で便利な標準ライブラリの仕組みとその使用例 https://izadori.net/cpp-templ-sfinae/# https://programming-place.net/ppp/contents/cpp/language/023.html#partial_specialization  ","permalink":"https://public-jun.github.io/cpp-enable-if/","summary":"1. はじめに  c++98 で STL コンテナを自作するときに enable_if を実装する必要があったので今回はそのまとめです。あくまで、c++98 ベースで作っていきます。\n前回の is_integral を使うので、場合によっては参照してください。\n2. SFINAE とは  cpprefjp より引用\n 「SFINAE (Substitution Failure Is Not An Errorの略称、スフィネェと読む)」は、テンプレートの置き換えに失敗した際に、即時にコンパイルエラーとはせず、置き換えに失敗した関数をオーバーロード解決の候補から除外するという言語機能である。\n テンプレート引数の展開に不正があっても、エラーにはならず候補から外され、コンパイルは続行される。\n残った候補の中から置き換えに成功したものを実行する。\nstruct Test {  typedef void type; };  template \u0026lt;typename T\u0026gt; void f(typename T::type) {} // 定義#1  template \u0026lt;typename T\u0026gt; void f(T) {} // 定義#2  int main() {  f\u0026lt;Test\u0026gt;(10); // 定義#1 の呼び出し  f\u0026lt;int\u0026gt;(10); // 定義#2 の呼び出し }  f\u0026lt;Test\u0026gt;(10) について、Test::type が存在するので 定義1 が実体化する。 f\u0026lt;int\u0026gt;(10) について、int型は int::type が存在しないので 定義1 が候補から除外され、 定義2 が実体化される。  このようにテンプレート実引数の型を調べて、実体化するテンプレート定義を決定することができる特徴がある。","title":"enable_if 作ってみた"},{"content":"1. はじめに  c++98 で STL コンテナを自作するときに is_integral を実装する必要があったので今回はそのまとめです。\n2. is_integral とは   cppreference.com より  //Defined in header \u0026lt;type_traits\u0026gt; namespace std {  template \u0026lt;class T\u0026gt;  struct is_integral;   template \u0026lt;class T\u0026gt;  inline constexpr bool is_integral_v = is_integral\u0026lt;T\u0026gt;::value; // C++17 }  Checks whether T is an integral type. Provides the member constant value which is equal to true, if T is the type bool, char, char8_t (since C++20), char16_t, char32_t, wchar_t, short, int, long, long long, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, value is equal to false.\n つまり型Tが整数型かを調べます。 T が整数型かどうかで true_type か false_type になるように integral_constant から継承します。\nis_integral\u0026lt;T\u0026gt;::value で bool値(true もしくは false) を取得することができます。\n 以下のような型が整数型として判定されます。\n bool char char16_t char32_t wchar_t signed char short int int long int long long int unsigned char unsigned short int unsigned int unsigned long int unsigned long long int  enum (列挙型) は c++ では整数型と 判定されません。\n3. 実装  実装のためには以下のクラステンプレートを理解する必要があります。\n integral_constatnt is_integral_helper remove_cv is_integral  integral_constant  template \u0026lt;class _Tp, _Tp __v\u0026gt; struct integral_constant {  static const _Tp value = __v;  typedef _Tp value_type;  typedef integral_constant\u0026lt;_Tp, __v\u0026gt; type;  // constexpr operator value_type() const noexcept { return value; } // c++11 なので未実装  const value_type operator()() const { return value; } };  // integral_constantの特殊化 true_type typedef integral_constant\u0026lt;bool, true\u0026gt; true_type;  // integral_constantの特殊化 false_type typedef integral_constant\u0026lt;bool, false\u0026gt; false_type; integral_constat は value と value_type の定義を持ち、実体化すると value に bool値が代入されます。\nそれぞれの特殊化は typedef によって true_type もしくは false_type に命名されます。\nis_integral_helper  template \u0026lt;class _Tp\u0026gt; struct is_integral_helper : public false_type {};  // int型でのクラステンプレートの完全特殊化 template \u0026lt;\u0026gt; struct is_integral_helper\u0026lt;int\u0026gt; : public true_type {};  // char型でのクラステンプレートの完全特殊化 template \u0026lt;\u0026gt; struct is_integral_helper\u0026lt;char\u0026gt; : public true_type {}; is_integral_helper はデフォルトでは false_type を継承し、int型やchar型などの整数型の場合は完全特殊化を用いて true_type を継承します。\n同様に他の型での完全特殊化も用意します。ここでは割愛します。\nremove_cv  現時点では int型やchar型は判定できるようになりますが、const int や volatile char などconst修飾子やvolatile修飾子(コンパイルの最適化を抑制する修飾子)がついていても整数型が判定できなければいけません。\n// default template \u0026lt;class _Tp\u0026gt; struct remove_cv {  typedef _Tp type; };  // remove const template \u0026lt;class _Tp\u0026gt; struct remove_cv\u0026lt;const _Tp\u0026gt; {  typedef _Tp type; };  // remove volatile template \u0026lt;class _Tp\u0026gt; struct remove_cv\u0026lt;volatile _Tp\u0026gt; {  typedef _Tp type; };  // remove const volatile template \u0026lt;class _Tp\u0026gt; struct remove_cv\u0026lt;const volatile _Tp\u0026gt; {  typedef _Tp type; }; remove_cv は部分特殊化を用いることで const 、 volatile 、 const volatile を取り除いた型を type で取得することができます。\n以上で is_integral を作る材料が揃いました。\nis_integral  template \u0026lt;class _Tp\u0026gt; struct is_integral : is_integral_helper\u0026lt;typename remove_cv\u0026lt;_Tp\u0026gt;::type\u0026gt;::type {}; これが is_integral の定義です。 is_integral\u0026lt;_Tp\u0026gt;::value で bool値を取得できます。\nぱっと見ではわかりづらいかもしれないので、具体例を示します。\n const int の場合   template \u0026lt;class const int\u0026gt; struct is_integral : is_integral_helper\u0026lt;typename remove_cv\u0026lt;const int\u0026gt;::type\u0026gt;::type {}; typename remove_cv\u0026lt;const int\u0026gt;::type に注目して\ntypename remove_cv\u0026lt;const int\u0026gt;::type /* ** const int の const が取り除かれ、 ** typedef int type として命名されるから */ typename int is_integral_helper\u0026lt;typename remove_cv\u0026lt;const int\u0026gt;::type\u0026gt;::type に注目して\n// remove_cv により is_integral_helper\u0026lt;int\u0026gt;::type  /* ** template\u0026lt;\u0026gt; ** struct is_integral_helper\u0026lt;int\u0026gt; : public true_type {}; ** より true_type の type メンバが使用できる */ true_type::type  /* ** true_type は integral_constant\u0026lt;bool, true\u0026gt; であるから ** 中身は */ struct integral_constant {  static const bool value = true;  typedef bool value_type;  typedef integral_constant\u0026lt;bool, true\u0026gt; type;  const value_type operator()() const { return value; } };  /* ** typedef integral_constant\u0026lt;bool, type\u0026gt; type; より */ struct is_integral : integral_constant\u0026lt;bool, true\u0026gt; {};  /* ** is_integral は integral_constant\u0026lt;bool, true\u0026gt; のメンバを利用できるから */ is_integral::value // true 流れとしては以上です。\n最後に  enable_if で今回の is_integral は用いるのですが、enable_if の実装自体はそんなに難しそうじゃなかったので、この記事に追記してもいいかもしれません。 完全特殊化、部分特殊化の理解が深まってよかったです。\n次は enable_if のこと書きます。\n. 参考URL  cppreference.com cplusplus cpprefjp gcc のソースコード is_integral 該当ファイル llvm のソースコード is_integral 該当ファイル  ","permalink":"https://public-jun.github.io/cpp-is-integral/","summary":"1. はじめに  c++98 で STL コンテナを自作するときに is_integral を実装する必要があったので今回はそのまとめです。\n2. is_integral とは   cppreference.com より  //Defined in header \u0026lt;type_traits\u0026gt; namespace std {  template \u0026lt;class T\u0026gt;  struct is_integral;   template \u0026lt;class T\u0026gt;  inline constexpr bool is_integral_v = is_integral\u0026lt;T\u0026gt;::value; // C++17 }  Checks whether T is an integral type. Provides the member constant value which is equal to true, if T is the type bool, char, char8_t (since C++20), char16_t, char32_t, wchar_t, short, int, long, long long, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants.","title":"c++98 で is_integral 実装"},{"content":"1. はじめに  STL コンテナを自作している時、 typename の使い方をしっかり理解していなかったので自分なりにまとめてみました。\n2. typename とは  cppreference.com typename の説明より\n  In the template parameter list of a template declaration, typename can be used as an alternative to class to declare type template parameters . Inside a declaration or a definition of a template, typename can be used to declare that a dependent qualified name is a type.    c++ のテンプレート宣言時には、型名を明示する際に class の代わりに typename を使用してテンプレートパラメータを宣言することができます。  template\u0026lt;typename T\u0026gt; void f() {} template\u0026lt;class T\u0026gt; void f() {} これはどちらでもコンパイルが通ります。\n テンプレートの宣言や定義の中で， typename はテンプレートパレメータ内部にネストされた依存型名が明示的に型である宣言をするために使うことができます．  例えば、以下の例を考えてみます。\n#include \u0026lt;iostream\u0026gt; class my_class { public:  enum type_ { val1 = 100 }; };  template\u0026lt;typename T\u0026gt; class test_my_class { public:  void print() {  // T::type_ val1 = T::type_::val1;  typename T::type_ val1 = T::type_::val1;  std::cout \u0026lt;\u0026lt; val1 \u0026lt;\u0026lt; std::endl;  } };  int main(int, char**) {  test_my_class\u0026lt;my_class\u0026gt; tc;  tc.print();  return 0; } test_my_class のクラステンプレートのテンプレート引数として my_class が与えられた状況です。\n// T::type_ val1 = T::type_::val1; typename T::type_ val1 = T::type_::val1; 上記 2 行の違いは typename がついているかどうかです。 1行目をコメントアウトしなければ、コンパイルが成功しません。 これはコンパイル時には T::type_ が クラス名::型 なのか クラス名::定数 なのか判断できないからです。\nこの問題を解決するために、ネストされた依存名(T) の 型(type_) を使う場合、明示的に typename を書きます。\ntypename Foo\u0026lt;T\u0026gt;::xxx //xxxは型名 最後に  今回は typename についてまとめてみました。 これで少し STL コンテナのコードを読めそうです。\n参考URL  https://en.cppreference.com/w/cpp/keyword/typename https://marycore.jp/prog/cpp/template-class-typename/ https://daily-tech.hatenablog.com/entry/2018/12/01/103658  ","permalink":"https://public-jun.github.io/cpp-typename/","summary":"1. はじめに  STL コンテナを自作している時、 typename の使い方をしっかり理解していなかったので自分なりにまとめてみました。\n2. typename とは  cppreference.com typename の説明より\n  In the template parameter list of a template declaration, typename can be used as an alternative to class to declare type template parameters . Inside a declaration or a definition of a template, typename can be used to declare that a dependent qualified name is a type.    c++ のテンプレート宣言時には、型名を明示する際に class の代わりに typename を使用してテンプレートパラメータを宣言することができます。  template\u0026lt;typename T\u0026gt; void f() {} template\u0026lt;class T\u0026gt; void f() {} これはどちらでもコンパイルが通ります。","title":"c++ における typename とは"},{"content":"1. はじめに Hugoで作ったサイトは共有された時、ブログカードはデフォルトでは作成されません。 ブログカードは下記の画像です。 タイトル、説明、画像といったものがのっています。 これらの情報を提供しているのが Open Graph Protocol(OGP) です。\n今回はブログカードの画像を用意して、Hugo の config ファイルに OGP の設定を記述しブログカードを作成します。\n2. Open Graph Protocol(OGP)、OGP 画像って何？？  公式より\n The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.\n OGP を用いると任意の Web ページをリッチなソーシャルグラフのオブジェクトにすることができます。\n要するに、ページのブログカードに必要な情報を取ってきてブログカードを作る仕組みの一つです。\nHTML の head 領域に任意のデータを記述できる meta 要素を追加し、ページ情報を記載することができます。OGP のデータであることを示すために、property 属性に og: から始まる値を記述します。\n基本的に必要なのは以下の 4 つです。\n og:title \u0026hellip; ページのタイトル og:type\u0026hellip; ページのオブジェクトタイプを表す、トップページは *website\u0026quot; 、それ以外は \u0026ldquo;article\u0026rdquo; og:image\u0026hellip; ページの画像 og:url\u0026hellip; ページのURL  この他にも og:site_name や og:description もよく利用されます。\nこのブログのトップページのOGP設定は以下\n\u0026lt;head\u0026gt; . . \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;Get stronger one day at a time.\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;1日ひとつ強くなる42Tokyo生の個人ブログです。\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;website\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;https://public-jun.github.io/\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;https://public-jun.github.io/first-blog-card-fs8.png\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:site_name\u0026#34; content=\u0026#34;jnakahod\u0026#39;s blog\u0026#34;\u0026gt; . \u0026lt;/head\u0026gt; 3. GIMPを使って画像作成  ドット絵の作成にはミニドット絵メーカー3、それを加工し編集するのに画像編集ソフトGIMP を利用しました。\nどちらも無料で使えます。 GIMP は OSS プロジェクトで有料サービスに劣らないくらい機能が盛り盛りだったのでびっくりしました。\n4. configファイル設定  Hugo には予め OGP 情報を head 内に埋め込む機能がついているので、config ファイルを設定し有効にしていきます。\n以下公式サイトの設定\nconfig.yml\nparams:  description: Text about my cool site  images:  - site-feature-image.jpg  title: My cool site taxonomies:  series: series 記事それぞれに情報を付与することも可能です。\ncontent/blog/my-post.yaml もしくは front matter 内に記述\naudio: [] date: \u0026#34;2006-01-02\u0026#34; description: Text about this post images: - post-cover.png series: [] tags: [] title: Post title videos: [] 私の config.yaml の場合は以下の設定です。\nparams:  .  .  description: 1日ひとつ強くなる42Tokyo生の個人ブログです。  images:  - first-blog-card-fs8.png  title: jnakahod\u0026#39;s blog Twitter カードもこれで設定できたことになります。\nlayout/partials/head.html もしくは thema/テーマ名/layout/partials/head.html の中の\n{{- template \u0026#34;partials/templates/opengraph.html\u0026#34; . }} {{- template \u0026#34;partials/templates/twitter_cards.html\u0026#34; . }} が有効になります。\nファイルの構成はテーマに依存するので、使用しているものに合わせて利用してください。ない場合は、追記してください。\n5. ブログカード完成 これでデプロイすると冒頭のようなブログカードの完成です。\n OGP確認  これを使うと各SNSにどのように共有されるのか確認できます。\n最後に  これでとりあえず欲しい機能は揃ってきたので、あとは淡々とアウトプットを増やしてきます。 また Hugo で気になる機能があったら積極的に触ってみようと思います。\nではまた👋\n","permalink":"https://public-jun.github.io/make-blog-card/","summary":"1. はじめに Hugoで作ったサイトは共有された時、ブログカードはデフォルトでは作成されません。 ブログカードは下記の画像です。 タイトル、説明、画像といったものがのっています。 これらの情報を提供しているのが Open Graph Protocol(OGP) です。\n今回はブログカードの画像を用意して、Hugo の config ファイルに OGP の設定を記述しブログカードを作成します。\n2. Open Graph Protocol(OGP)、OGP 画像って何？？  公式より\n The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.\n OGP を用いると任意の Web ページをリッチなソーシャルグラフのオブジェクトにすることができます。\n要するに、ページのブログカードに必要な情報を取ってきてブログカードを作る仕組みの一つです。","title":"Hugo で作ったサイトにブログカード(OGP)を設定"},{"content":"1. はじめに Hugo でブログを作ってみたものの、デフォルトではコメント機能はついていません。\n今回はUtterancesを使ってみたいと思います。\n2. Hugoのコメント機能  Hugo にコメント機能をつける場合、いくつか選択肢があります。\n鉄板は Disqus でしょうか。これは公式が Hugo をサポートしています。\nDocs にも唯一設定手順が書いてあります。\n以下、ドキュメントに紹介されているもの\n Cactus Comments Commento Graph Comment Hyvor Talk IntenseDebate Isso Muut Remark42 Staticman Talkyard Utterances  Disqus を使わない理由は無料プランだと広告がつくみたいです。あと登録するのも少し面倒に感じました。\nでも今回使う Utterances は GitHub のアカウントだけなので、(一応想定読者はテックの人なので) GitHub の認証のみならコメントのハードルも低いかなと思いこれに決めました。\nあと見た目がいい😊\nUtterancesとは？？  A lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more!\n Utterances は軽量なコンポーネントと GitHub issues にコメントを書きこむ bot を提供しています。 これを使うと GitHub の issue と記事やページを紐付け、ページに issue を表示することができます。\nOSS プロジェクトでスター6kついており、かなりの人が使っています。\nテーマもいくつか用意されていて良きです。\nトラックなし、広告なし、その上機能は全て無料です。\n3. Utterancesの導入  今回は Utterances に絞って説明していきます。 前提として Hugo のサイトを GitHub の public なリポジトリで管理しているとします。 また使用テーマは PaperMod です。\n基本的には公式サイトを見ながら設定していけば ok です。\n  リポジトリに utterances app をインストール\n  フォームにリポジトリの所有者とリポジトリ名を入力 私の場合は public-jun/public-jun.github.io です。\n  記事と GitHub の issue を紐付ける。今回は pathname で設定します。   GitHub の issue でのラベルを決める。これは任意のラベルで大丈夫です。今回はコメントと分かるように Comment とします。\n  テーマを決める。お好きなテーマを選んでください。\n  ここまですると一番したに設定用のスクリプトが表示されます。\nこれを layout/partials/comments.html 新たに作成し貼り付けます。\n\u0026lt;script \tsrc=\u0026#34;https://utteranc.es/client.js\u0026#34; \trepo=\u0026#34;owner/repo\u0026#34; \tissue-term=\u0026#34;pathname\u0026#34; \tlabel=\u0026#34;Comment\u0026#34; \ttheme=\u0026#34;github-light\u0026#34; \tcrossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; confing.yml\nparams:  comments: true これを追記することでthemes/PaperMod/layouts/_default/single.html の\n {{- if (.Param \u0026#34;comments\u0026#34;) }}  {{- partial \u0026#34;comments.html\u0026#34; . }}  {{- end }} が有効となりコメントが表示されます。\n4. コメントする  実際にコメントしてみるとこんな感じ 5. 最後に これでいい感じにコメント機能が追加できたと思います。 もし読んでくださった方がいたら、コメントくれると嬉しいです😄\nダークモードとライトモードでテーマが切り替えられるようにしたいです。 明日はそろそろ取り組んでいる課題の記事にしていきたい。\n参考URL  https://utteranc.es/ https://miyauchi.dev/ja/posts/comment-system/ https://mscipio.github.io/post/utterances-comment-engine/  ","permalink":"https://public-jun.github.io/Hugo-utterances/","summary":"1. はじめに Hugo でブログを作ってみたものの、デフォルトではコメント機能はついていません。\n今回はUtterancesを使ってみたいと思います。\n2. Hugoのコメント機能  Hugo にコメント機能をつける場合、いくつか選択肢があります。\n鉄板は Disqus でしょうか。これは公式が Hugo をサポートしています。\nDocs にも唯一設定手順が書いてあります。\n以下、ドキュメントに紹介されているもの\n Cactus Comments Commento Graph Comment Hyvor Talk IntenseDebate Isso Muut Remark42 Staticman Talkyard Utterances  Disqus を使わない理由は無料プランだと広告がつくみたいです。あと登録するのも少し面倒に感じました。\nでも今回使う Utterances は GitHub のアカウントだけなので、(一応想定読者はテックの人なので) GitHub の認証のみならコメントのハードルも低いかなと思いこれに決めました。\nあと見た目がいい😊\nUtterancesとは？？  A lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more!\n Utterances は軽量なコンポーネントと GitHub issues にコメントを書きこむ bot を提供しています。 これを使うと GitHub の issue と記事やページを紐付け、ページに issue を表示することができます。","title":"HugoのサイトにUtterancesを使ってコメント機能をつける"},{"content":"1. はじめに Hugoで作った静的サイトはそのままの設定ではGoogle検索にはかからないので、いくつか設定をしないといけません。\nGoogle検索で表示されるまで   Google Analyticsに登録 Google Search Consoleに登録  今回は Google Analytics 登録編です。\n2. やってみる 測定を開始をクリック\n任意のアカウント名にして次へ\n プロパティ(サイトやアプリの名前) タイムゾーン 通貨 を入力して次へ  上から順に記入していけば大丈夫です。\nプラットフォームはwebを選択\nwebサイト のURLを入力します。このサイトではhttps:///public-jun.github.ioのようになります。 ストリーム名はwebサイトのタイトルを入力すれば大丈夫です。\nストリームを作成すると測定IDが生成されます。\nHugoの設定  Hugoの場合、google analytics設定用のテンプレートが用意されているのでconfigファイルに追記します。\nconfig.yml:(Google Analytics v4 (gtag.js))の場合、測定IDがGからはじまる\ngoogleAnalytics: G-MEASUREMENT_ID config.yml:Google Analytics v3 (analytics.js)の場合、測定IDがUAからはじまる\ngoogleAnalytics: UA-PROPERTY_ID 現在はgtagsで設定しておけば良いと思います。\nこれでHugo側の設定は完了です。 アップロードして確認してみましょう。\nGoogle Analyticsのレポート -\u0026gt; リアルタイム を確認してみて、自分がアクセスしたときにユーザー数が0以外であれば成功です😄\n最後に 次回はGoogle Search Consoleの設定をしてみたいと思いますがどうやら登録に時間がかかる場合もあるらしく、まだできていません。 登録出来次第まとめたいと思います。\n","permalink":"https://public-jun.github.io/Hugo-google-analytics/","summary":"1. はじめに Hugoで作った静的サイトはそのままの設定ではGoogle検索にはかからないので、いくつか設定をしないといけません。\nGoogle検索で表示されるまで   Google Analyticsに登録 Google Search Consoleに登録  今回は Google Analytics 登録編です。\n2. やってみる 測定を開始をクリック\n任意のアカウント名にして次へ\n プロパティ(サイトやアプリの名前) タイムゾーン 通貨 を入力して次へ  上から順に記入していけば大丈夫です。\nプラットフォームはwebを選択\nwebサイト のURLを入力します。このサイトではhttps:///public-jun.github.ioのようになります。 ストリーム名はwebサイトのタイトルを入力すれば大丈夫です。\nストリームを作成すると測定IDが生成されます。\nHugoの設定  Hugoの場合、google analytics設定用のテンプレートが用意されているのでconfigファイルに追記します。\nconfig.yml:(Google Analytics v4 (gtag.js))の場合、測定IDがGからはじまる\ngoogleAnalytics: G-MEASUREMENT_ID config.yml:Google Analytics v3 (analytics.js)の場合、測定IDがUAからはじまる\ngoogleAnalytics: UA-PROPERTY_ID 現在はgtagsで設定しておけば良いと思います。\nこれでHugo側の設定は完了です。 アップロードして確認してみましょう。\nGoogle Analyticsのレポート -\u0026gt; リアルタイム を確認してみて、自分がアクセスしたときにユーザー数が0以外であれば成功です😄\n最後に 次回はGoogle Search Consoleの設定をしてみたいと思いますがどうやら登録に時間がかかる場合もあるらしく、まだできていません。 登録出来次第まとめたいと思います。","title":"HugoでGoogle Analyticsを使う"},{"content":"きっかけ ブログにタグ機能が欲しかったから。\nTaxonomyって何？？  Hugo includes support for user-defined groupings of content called taxonomies. Taxonomies are classifications of logical relationships between content.\n タグやカテゴリなどのユーザーが定義した分類のことをタクソノミーという。\n  タクソノミー(Taxonomy)\nコンテンツをグルーピングするための分類法\n  ターム(Term)\n実際の具体的なタグやカテゴリの値\n  Taxonomyを使う  Hugoはデフォルトでタグとカテゴリをサポートしている。\nconfingの設定 config.yml\ntaxonomies:  category: categories  tag: tags https://[サイトURL]/tags/\nhttps://[サイトURL]/categories/\n上記のURLにアクセスするとタグ一覧、カテゴリ一覧ページへアクセスできる。\nちなみにこのサイトでは\n  https://public-jun.github.io/tags/\n  https://public-jun.github.io/categories/\n  となる。\n記事の Front matter内でタグ、カテゴリ追加 contents/posts/../記事.md\n--- title: \u0026#34;HugoのサイトにTag機能を追加\u0026#34; date: 2022-02-04T15:39:20+09:00 draft: false tags: [42Tokyo, blog, Hugo, TIL] //追加 categories: [Tech] //追加 . .  --- これで「42Tokyo」、「blog」、「Hugo」、「TIL」タグが追加され、\n記事自身は「Tech」というカテゴリに分類された。\n画面上部にMenu表示(Papermod)  PaperModテーマはホームページ右上にMenu(ページへのショートカット)を作成することができる。\nconfig.yml\nmenu:  main:  - identifier: tags  name: Tags  url: /tags/  weight: 1  - identifier: categories  name: Categories  url: /categories/  weight: 2 このように設定すると画面右上にTagsとcategoriesへのMenuを表示することができる。\n終わり  次はコメント機能の追加やgoogle analyticsの導入にチャレンジしよかな。\n42Tokyoの課題も学んだことアウトプットしていきます🙌\n参考URL   HUGO document\n  https://hugo-de-blog.com/hugo-taxonomy/\n  https://maku77.github.io/hugo/taxonomy/basic.html\n  ","permalink":"https://public-jun.github.io/custom-taxonomies/","summary":"きっかけ ブログにタグ機能が欲しかったから。\nTaxonomyって何？？  Hugo includes support for user-defined groupings of content called taxonomies. Taxonomies are classifications of logical relationships between content.\n タグやカテゴリなどのユーザーが定義した分類のことをタクソノミーという。\n  タクソノミー(Taxonomy)\nコンテンツをグルーピングするための分類法\n  ターム(Term)\n実際の具体的なタグやカテゴリの値\n  Taxonomyを使う  Hugoはデフォルトでタグとカテゴリをサポートしている。\nconfingの設定 config.yml\ntaxonomies:  category: categories  tag: tags https://[サイトURL]/tags/\nhttps://[サイトURL]/categories/\n上記のURLにアクセスするとタグ一覧、カテゴリ一覧ページへアクセスできる。\nちなみにこのサイトでは\n  https://public-jun.github.io/tags/\n  https://public-jun.github.io/categories/\n  となる。\n記事の Front matter内でタグ、カテゴリ追加 contents/posts/../記事.md\n--- title: \u0026#34;HugoのサイトにTag機能を追加\u0026#34; date: 2022-02-04T15:39:20+09:00 draft: false tags: [42Tokyo, blog, Hugo, TIL] //追加 categories: [Tech] //追加 .","title":"HugoのサイトにTag機能を追加"},{"content":"こんにちは、jnakahodです\n日々学んだことを気軽にアウトプットしようと思いブログを作りました。 他のブログサービスを使うより気軽になんでも書けるので個人ブログにしました。\nできるだけ毎日、その日学んだこと投稿するのが目標です。\nちゃんとした記事ははてブとかに投稿しようかな。。\n","permalink":"https://public-jun.github.io/posts/my-first-posts/","summary":"こんにちは、jnakahodです\n日々学んだことを気軽にアウトプットしようと思いブログを作りました。 他のブログサービスを使うより気軽になんでも書けるので個人ブログにしました。\nできるだけ毎日、その日学んだこと投稿するのが目標です。\nちゃんとした記事ははてブとかに投稿しようかな。。","title":"Hello World!!"}]